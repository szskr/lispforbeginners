     1	; Copyright (c) 2005-2009 by Juliusz Chroboczek
     2	
     3	; Permission is hereby granted, free of charge, to any person obtaining a copy
     4	; of this software and associated documentation files (the "Software"), to deal
     5	; in the Software without restriction, including without limitation the rights
     6	; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     7	; copies of the Software, and to permit persons to whom the Software is
     8	; furnished to do so, subject to the following conditions:
     9	
    10	; The above copyright notice and this permission notice shall be included in
    11	; all copies or substantial portions of the Software.
    12	
    13	; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    14	; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    15	; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
    16	; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    17	; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    18	; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    19	; THE SOFTWARE.
    20	
    21	(defpackage #:yacc
    22	  (:use #:common-lisp)
    23	  (:export #:make-production #:make-grammar #:make-parser #:parse-with-lexer
    24	           #:define-grammar #:define-parser
    25	           #:yacc-compile-warning #:conflict-warning #:conflict-summary-warning
    26	           #:yacc-runtime-error #:yacc-parse-error #:yacc-parse-error-terminal
    27	           #:yacc-parse-error-value #:yacc-parse-error-expected-terminals)
    28	  #+CMU
    29	  (:import-from #:extensions #:required-argument #:memq)
    30	  )
    31	
    32	(in-package #:yacc)
    33	
    34	#-CMU
    35	(defun required-argument () (error "A required argument was not supplied"))
    36	
    37	#-CMU
    38	(declaim (inline memq))
    39	
    40	#-CMU
    41	(defun memq (item list)
    42	  "MEMBER :TEST #'EQ"
    43	  (member item list :test #'eq))
    44	
    45	(deftype index () '(unsigned-byte 14))
    46	(deftype signed-index () '(signed-byte 15))
    47	
    48	;;; Productions
    49	
    50	(defstruct (production
    51	             (:constructor make-production (symbol derives
    52	                                            &key action action-form))
    53	             (:print-function print-production))
    54	  (id nil :type (or null index))
    55	  (symbol (required-argument) :type symbol)
    56	  (derives (required-argument) :type list)
    57	  (action #'list :type function)
    58	  (action-form nil))
    59	
    60	(defun print-production (p s d)
    61	  (declare (type production p) (stream s) (ignore d))
    62	  (print-unreadable-object (p s :type t)
    63	    (format s "~S -> ~{~S~^ ~}" (production-symbol p) (production-derives p))))
    64	
    65	(declaim (inline production-equal-p))
    66	(defun production-equal-p (p1 p2)
    67	  "Equality predicate for productions within a single grammar"
    68	  (declare (type production p1 p2))
    69	  (eq p1 p2))
    70	
    71	(declaim (inline production<))
    72	(defun production< (p1 p2)
    73	  "Total order on productions within a single grammar"
    74	  (declare (type production p1 p2))
    75	  (< (production-id p1) (production-id p2)))
    76	
    77	 ;;; Grammars
    78	
    79	(defstruct (grammar (:constructor %make-grammar))
    80	  (name nil)
    81	  (terminals '() :type list)
    82	  (precedence '() :type list)
    83	  (productions '() :type list)
    84	  (%symbols :undefined :type (or list (member :undefined)))
    85	  (derives-epsilon '() :type list)
    86	  (derives-first '() :type list)
    87	  (derives-first-terminal '() :type list))
    88	
    89	(defun make-grammar(&key name (start-symbol (required-argument))
    90	                    terminals precedence productions)
    91	  (declare (symbol name start-symbol) (list terminals productions))
    92	  (setq productions
    93	        (cons (make-production 's-prime (list start-symbol)
    94	                               :action #'identity :action-form '#'identity)
    95	              productions))
    96	  (do* ((i 0 (+ i 1)) (ps productions (cdr ps)) (p (car ps) (car ps)))
    97	       ((null ps))
    98	    (setf (production-id p) i))
    99	  (%make-grammar :name name :terminals terminals :precedence precedence
   100	                 :productions productions))
   101	
   102	(defun grammar-discard-memos (grammar)
   103	  (setf (grammar-%symbols grammar) :undefined)
   104	  (setf (grammar-derives-epsilon grammar) '())
   105	  (setf (grammar-derives-first grammar) '())
   106	  (setf (grammar-derives-first-terminal grammar) '()))
   107	
   108	(defun terminal-p (symbol grammar)
   109	  (declare (symbol symbol) (type grammar grammar))
   110	  (or (eq symbol 'propagate)
   111	      (and (member symbol (grammar-terminals grammar)) t)))
   112	
   113	(defun grammar-symbols (grammar)
   114	  "The set of symbols (both terminal and nonterminal) of GRAMMAR."
   115	  (declare (type grammar grammar))
   116	  (cond
   117	    ((eq :undefined (grammar-%symbols grammar))
   118	     (let ((res '()))
   119	       (dolist (p (grammar-productions grammar))
   120	         (pushnew (production-symbol p) res)
   121	         (dolist (s (production-derives p))
   122	           (pushnew s res)))
   123	       (setf (grammar-%symbols grammar) res)
   124	       res))
   125	    (t (grammar-%symbols grammar))))
   126	
   127	(defun grammar-epsilon-productions (grammar)
   128	  (remove-if-not #'(lambda (r) (null (production-derives r)))
   129	                 (grammar-productions grammar)))
   130	
   131	(defun derives-epsilon (symbol grammar &optional seen)
   132	  "True if symbol derives epsilon."
   133	  (declare (symbol symbol) (type grammar grammar) (list seen))
   134	  (let ((e (assoc symbol (grammar-derives-epsilon grammar))))
   135	    (cond
   136	      (e (cdr e))
   137	      ((terminal-p symbol grammar) nil)
   138	      ((member symbol seen) nil)
   139	      (t
   140	       (let ((res (derives-epsilon* symbol grammar (cons symbol seen))))
   141	         (when (or res (null seen))
   142	           (setf (grammar-derives-epsilon grammar)
   143	                 (acons symbol res (grammar-derives-epsilon grammar))))
   144	         res)))))
   145	
   146	(defun derives-epsilon* (symbol grammar &optional seen)
   147	  "Unmemoised version of DERIVES-EPSILON."
   148	  (declare (symbol symbol) (type grammar grammar) (list seen))
   149	  (dolist (production (grammar-productions grammar))
   150	    (when (and (eq symbol (production-symbol production))
   151	               (every #'(lambda (s) (derives-epsilon s grammar seen))
   152	                      (production-derives production)))
   153	      (return t))))
   154	
   155	(defun sequence-derives-epsilon (sequence grammar)
   156	  "Sequence version of DERIVES-EPSILON*."
   157	  (declare (list sequence) (type grammar grammar))
   158	  (every #'(lambda (s) (derives-epsilon s grammar)) sequence))
   159	
   160	(defun print-derives-epsilon (grammar &optional (stream *standard-output*))
   161	  (let ((seen '()) (de '()))
   162	    (dolist (p (grammar-productions grammar))
   163	      (let ((s (production-symbol p)))
   164	        (unless (member s seen)
   165	          (push s seen)
   166	          (when (derives-epsilon s grammar)
   167	            (push s de)))))
   168	    (format stream "~D symbols derive epsilon:~%~S~%~%"
   169	            (length de) (nreverse de))))
   170	
   171	(defun derives-first (c grammar &optional seen)
   172	  "The list of symbols A such that C rm->* A.eta for some eta."
   173	  (declare (symbol c) (type grammar grammar) (list seen))
   174	  (let ((e (assoc c (grammar-derives-first grammar))))
   175	    (cond
   176	      (e (the list (cdr e)))
   177	      ((terminal-p c grammar) (list c))
   178	      ((member c seen) '())
   179	      (t
   180	       (let ((derives (list c)))
   181	         (declare (list derives))
   182	         (dolist (production (grammar-productions grammar))
   183	           (when (eq c (production-symbol production))
   184	             (setq derives
   185	                   (union (sequence-derives-first
   186	                           (production-derives production) grammar
   187	                           (cons c seen))
   188	                          derives))))
   189	         (when (null seen)
   190	           (setf (grammar-derives-first grammar)
   191	                 (acons c derives (grammar-derives-first grammar))))
   192	         derives)))))
   193	
   194	(defun sequence-derives-first (sequence grammar &optional seen)
   195	  "Sequence version of DERIVES-FIRST."
   196	  (declare (list sequence) (type grammar grammar) (list seen))
   197	  (cond
   198	    ((null sequence) '())
   199	    ((terminal-p (car sequence) grammar) (list (car sequence)))
   200	    (t
   201	     (let ((d1 (derives-first (car sequence) grammar seen)))
   202	       (if (derives-epsilon (car sequence) grammar)
   203	           (union d1 (sequence-derives-first (cdr sequence) grammar seen))
   204	           d1)))))
   205	
   206	(defun derives-first-terminal (c grammar &optional seen)
   207	  "The list of terminals a such that C rm->* a.eta, last non-epsilon."
   208	  (declare (symbol c) (type grammar grammar))
   209	  (let ((e (assoc c (grammar-derives-first-terminal grammar))))
   210	    (cond
   211	      (e (the list (cdr e)))
   212	      ((terminal-p c grammar) (list c))
   213	      ((member c seen) '())
   214	      (t
   215	       (let ((derives '()))
   216	         (declare (list derives))
   217	         (dolist (production (grammar-productions grammar))
   218	           (when (eq c (production-symbol production))
   219	             (setq derives
   220	                   (union
   221	                    (sequence-derives-first-terminal
   222	                     (production-derives production) grammar (cons c seen))
   223	                    derives))))
   224	         (when (null seen)
   225	           (push (cons c derives) (grammar-derives-first-terminal grammar)))
   226	         derives)))))
   227	
   228	(defun sequence-derives-first-terminal (sequence grammar &optional seen)
   229	  "Sequence version of DERIVES-FIRST-TERMINAL."
   230	  (declare (list sequence) (type grammar grammar) (list seen))
   231	  (cond
   232	    ((null sequence) '())
   233	    (t
   234	     (derives-first-terminal (car sequence) grammar seen))))
   235	
   236	(defun first-terminals (s grammar)
   237	  "FIRST(s) without epsilon."
   238	  (declare (atom s) (type grammar grammar))
   239	  (cond
   240	    ((terminal-p s grammar) (list s))
   241	    (t (remove-if-not #'(lambda (s) (terminal-p s grammar))
   242	                      (derives-first s grammar)))))
   243	
   244	(defun sequence-first-terminals (s grammar)
   245	  "Sequence version of FIRST-TERMINALS."
   246	  (declare (list s) (type grammar grammar))
   247	  (cond
   248	    ((null s) '())
   249	    (t (let ((sf (first-terminals (car s) grammar)))
   250	         (if (derives-epsilon (car s) grammar)
   251	             (union sf (sequence-first-terminals (cdr s) grammar))
   252	             sf)))))
   253	
   254	(defun print-first-terminals (grammar &optional (stream *standard-output*))
   255	  "Print FIRST (without epsilon) for all symbols of GRAMMAR."
   256	  (let ((df '()))
   257	    (dolist (p (grammar-productions grammar))
   258	      (let ((s (production-symbol p)))
   259	        (unless (assoc s df)
   260	          (push (cons s (first-terminals s grammar)) df))))
   261	    (format stream "First terminals:~%")
   262	    (dolist (e (nreverse df))
   263	      (format stream "~S: ~S~%" (car e) (cdr e)))
   264	    (format stream "~%")))
   265	
   266	(defun sequence-first (s grammar)
   267	  "FIRST(s)."
   268	  (declare (list s) (type grammar grammar))
   269	  (let ((sf (sequence-first-terminals s grammar)))
   270	    (if (sequence-derives-epsilon s grammar)
   271	        (cons 'epsilon sf)
   272	        sf)))
   273	
   274	(defun combine-first (f1 s grammar)
   275	  "FIRST(s1.s) where f1=FIRST(s1)."
   276	  (declare (list f1 s) (type grammar grammar))
   277	  (if (member 'epsilon f1)
   278	      (union (remove 'epsilon f1) (sequence-first s grammar))
   279	      f1))
   280	
   281	(defun relative-first (s a grammar &optional seen)
   282	  "Union of FIRST(eta) for all the eta s.t. S rm->* Aeta."
   283	  (declare (symbol s a) (type grammar grammar) (list seen))
   284	  (cond
   285	    ((terminal-p s grammar) '())
   286	    ((member s seen) '())
   287	    (t (let ((res '()))
   288	         (when (and (eq s a) (derives-epsilon s grammar))
   289	           (push 'epsilon res))
   290	         (dolist (p (grammar-productions grammar))
   291	           (when (and (eq s (production-symbol p))
   292	                      (not (null (production-derives p))))
   293	             (setf res
   294	                   (union res
   295	                          (relative-first-sequence
   296	                           (production-derives p)
   297	                           a grammar (cons s seen))))))
   298	         res))))
   299	
   300	(defun relative-first-sequence (s a grammar &optional seen)
   301	  "Sequence version of RELATIVE-FIRST."
   302	  (declare (list s seen) (symbol a) (type grammar grammar))
   303	  (cond
   304	    ((null s) '())
   305	    ((equal s (list a)) (list 'epsilon))
   306	    ((not (member a (derives-first (car s) grammar))) '())
   307	    ((eq (car s) a) (sequence-first (cdr s) grammar))
   308	    (t (relative-first (car s) a grammar seen))))
   309	
   310	;;; Items
   311	
   312	(defstruct (item
   313	             (:constructor nil)
   314	             (:print-function print-item)
   315	             (:copier %copy-item))
   316	  (production (required-argument) :type production)
   317	  (position (required-argument) :type index))
   318	
   319	(defstruct (lr0-item
   320	             (:include item)
   321	             (:constructor make-item (production position))
   322	             (:conc-name item-))
   323	  (lookaheads '() :type list))
   324	
   325	(defstruct (lr1-item
   326	             (:include item)
   327	             (:constructor make-lr1-item
   328	                           (production position lookahead))
   329	             (:conc-name item-))
   330	  (lookahead (required-argument) :type symbol))
   331	
   332	(defun print-item (i s d)
   333	  (declare (type item i) (stream s) (ignore d))
   334	  (print-unreadable-object (i s :type t)
   335	    (format s "~S -> ~{~S ~}. ~{~S~^ ~}"
   336	            (item-symbol i) (item-dot-left i) (item-dot-right i))
   337	    (when (lr1-item-p i)
   338	      (format s " (~S)" (item-lookahead i)))))
   339	
   340	(declaim (inline item-derives item-symbol item-action
   341	                 item-dot-right-p item-dot-right item-dot-symbol
   342	                 item-lr1-equal-p item-lr1-hash-value item-equal-p))
   343	
   344	(defun item-derives (item)
   345	  (declare (type item item))
   346	  (production-derives (item-production item)))
   347	
   348	(defun item-symbol (item)
   349	  (declare (type item item))
   350	  (production-symbol (item-production item)))
   351	
   352	(defun item-action (item)
   353	  (declare (type item item))
   354	  (production-action (item-production item)))
   355	
   356	(defun item-action-form (item)
   357	  (declare (type item item))
   358	  (production-action-form (item-production item)))
   359	
   360	(defun item-lr1-equal-p (i1 i2)
   361	  "Equality predicate for LR(1) items."
   362	  (declare (type lr1-item i1 i2))
   363	  (or (eq i1 i2)
   364	      (and (eq (item-production i1) (item-production i2))
   365	           (= (item-position i1) (item-position i2))
   366	           (eq (item-lookahead i1) (item-lookahead i2)))))
   367	
   368	(defun item-equal-p (i1 i2)
   369	  "Equality predicate for LR(0) items."
   370	  (declare (type item i1 i2))
   371	  (or (eq i1 i2)
   372	      (and (eq (item-production i1) (item-production i2))
   373	           (= (item-position i1) (item-position i2)))))
   374	
   375	(defun item-lr1-hash-value (item)
   376	  "Returns an object suitable for keying associations of LR1-items."
   377	  (declare (type lr1-item item))
   378	  (cons (production-id (item-production item))
   379	        (cons (item-position item)
   380	              (item-lookahead item))))
   381	
   382	(defun item< (i1 i2)
   383	  "Total strict order on LR(0) items."
   384	  (declare (type item i1 i2))
   385	  (cond
   386	    ((eq i1 i2) nil)
   387	    ((production< (item-production i1) (item-production i2)) t)
   388	    ((not (eq (item-production i1) (item-production i2))) nil)
   389	    (t (< (item-position i1) (item-position i2)))))
   390	
   391	(defun item-set-equal-p (c1 c2)
   392	  "Equality predicate for sorted sets of LR(0) items."
   393	  (declare (list c1 c2))
   394	  (cond
   395	    ((eq c1 c2) t)
   396	    (t (do ((d1 c1 (cdr d1)) (d2 c2 (cdr d2)))
   397	           ((or (eq d1 d2) (null d1) (null d2)) (eq d1 d2))
   398	         (when (not (item-equal-p (car d1) (car d2)))
   399	           (return nil))))))
   400	
   401	(defun item-dot-right-p (item)
   402	  (declare (type item item))
   403	  (= (item-position item) (length (item-derives item))))
   404	
   405	(defun item-dot-symbol (item)
   406	  (declare (type item item))
   407	  (nth (item-position item) (item-derives item)))
   408	
   409	(defun item-dot-left (item)
   410	  (subseq (item-derives item) 0 (item-position item)))
   411	
   412	(defun item-dot-right (item &optional (n 0))
   413	  (declare (type signed-index n) #+CMU (optimize ext:inhibit-warnings))
   414	  (nthcdr (+ n (item-position item)) (item-derives item)))
   415	
   416	(defun item-shift (item &optional (n 1))
   417	  (declare (type lr0-item item) (type signed-index n))
   418	  (make-item (item-production item) (+ (item-position item) n)))
   419	
   420	(defun lr1-item-shift (item &optional (n 1))
   421	  (declare (type lr1-item item) (type signed-index n))
   422	  (make-lr1-item (item-production item) (+ (item-position item) n)
   423	                 (item-lookahead item)))
   424	
   425	
   426	;;; Sets of items
   427	
   428	(defstruct (kernel
   429	             (:constructor %make-kernel (items))
   430	             (:print-function print-kernel))
   431	  (id nil :type (or null index))
   432	  (items '() :type list)
   433	  (gotos '() :type list))
   434	
   435	(defun print-kernel (k s d)
   436	  (declare (type kernel k) (stream s) (ignore d))
   437	  (print-unreadable-object (k s :type t)
   438	    (format s "~{~<~D ~:_~:>~}~_ ~D"
   439	            (kernel-items k) (length (kernel-gotos k)))
   440	    (when (kernel-id k)
   441	      (format s " id=~D" (kernel-id k)))))
   442	
   443	(defun make-kernel (items &optional kernels)
   444	  (declare (list items kernels))
   445	  (let* ((items (sort (copy-list items) #'item<))
   446	         (k (find items kernels
   447	                  :key #'kernel-items :test #'item-set-equal-p)))
   448	    (or k (%make-kernel items))))
   449	
   450	(defun kernel-item (kernel)
   451	  "The item in a singleton set of items."
   452	  (declare (type kernel kernel))
   453	  (assert (null (cdr (kernel-items kernel))))
   454	  (the lr0-item (car (kernel-items kernel))))
   455	
   456	;; Items-closure starts by using a list, and switches to hashtables
   457	;; later.  Using some sort of balanced tree would probably be better.
   458	
   459	(defparameter *items-closure-hash-threshold* 20
   460	  "The number of elements when items-closure switches to using a hashtable.")
   461	(declaim (type index *items-closure-hash-threshold*))
   462	
   463	(deftype lr1-collection () '(or list hash-table))
   464	
   465	(defun make-lr1-collection (&optional same-kind-as)
   466	  (etypecase same-kind-as
   467	    (list '())
   468	    (hash-table (make-hash-table :test #'equal))))
   469	
   470	(defun lr1-collection-empty-p (collection)
   471	  (declare (type lr1-collection collection))
   472	  (typecase collection
   473	    (list (null collection))
   474	    (hash-table (zerop (hash-table-count collection)))))
   475	
   476	(defun clear-lr1-collection (collection)
   477	  (declare (type lr1-collection collection))
   478	  (typecase collection
   479	    (list '())
   480	    (hash-table (clrhash collection))))
   481	
   482	(defun make-hash-table-from-lr1-list (l)
   483	  (declare (list l))
   484	  (let ((h (make-hash-table :test #'equal)))
   485	    (dolist (item l)
   486	      (declare (type item item))
   487	      (setf (gethash (item-lr1-hash-value item) h) item))
   488	    h))
   489	
   490	(declaim (inline lr1-find))
   491	
   492	(defun lr1-find (item collection)
   493	  "Find an LR(1) item equal to ITEM in COLLECTION, or NIL."
   494	  (declare (optimize (speed 3) (space 0)))
   495	  (declare (type item item) (type lr1-collection collection))
   496	  (typecase collection
   497	    (list (find item collection :test #'item-lr1-equal-p))
   498	    (hash-table (gethash (item-lr1-hash-value item) collection))))
   499	
   500	(defun map-lr1-collection (f collection)
   501	  "Apply F to all elements of COLLECTION."
   502	  (declare (type function f) (dynamic-extent f)
   503	           (type lr1-collection collection))
   504	  (typecase collection
   505	    (list (mapcar f collection))
   506	    (hash-table (maphash #'(lambda (k v) (declare (ignore k)) (funcall f v))
   507	                         collection))))
   508	
   509	(defmacro do-lr1-collection ((var collection) &body body)
   510	  (let ((c-name (gensym "COLLECTION")) (f-name (gensym "DO-LR1-BODY")))
   511	    `(let ((,c-name ,collection))
   512	       (flet ((,f-name (,var) (declare (type lr1-item ,var)) ,@body))
   513	         (declare (dynamic-extent #',f-name))
   514	         (map-lr1-collection #',f-name ,c-name)))))
   515	
   516	(declaim (inline lr1-add))
   517	
   518	(defun lr1-add (item collection)
   519	  "Add ITEM to COLLECTION."
   520	  (declare (type lr1-item item) (type lr1-collection collection))
   521	  (typecase collection
   522	    (list (cons item collection))
   523	    (hash-table
   524	     (setf (gethash (item-lr1-hash-value item) collection) item)
   525	     collection)))
   526	
   527	(defun lr1-add-collection (items collection)
   528	  "Add all the elements of ITEMS to COLLECTION."
   529	  (declare (type lr1-collection items collection))
   530	  (typecase items
   531	    (list
   532	     (typecase collection
   533	       (list (nconc items collection))
   534	       (hash-table
   535	        (dolist (item items)
   536	          (setf (gethash (item-lr1-hash-value item) collection) item))
   537	        collection)))
   538	    (hash-table
   539	     (typecase collection
   540	       (list (error "This cannot happen"))
   541	       (hash-table
   542	        (maphash #'(lambda (k v) (setf (gethash k collection) v))
   543	                 items)
   544	        collection)))))
   545	
   546	(defun items-closure (items grammar)
   547	  "Compute the closure of a set of LR(1) items."
   548	  (declare (list items) (type grammar grammar))
   549	  (let ((res '()) (n 0)
   550	        (threshold *items-closure-hash-threshold*))
   551	    (declare (optimize (speed 3) (space 0)))
   552	    (declare (type index n) (type (or list hash-table) res))
   553	    (labels ((add (item)
   554	               (declare (type lr1-item item))
   555	               (unless (lr1-find item res)
   556	                 (setf res (lr1-add item res))
   557	                 (when (listp res)
   558	                   (incf n)
   559	                   (when (> n threshold)
   560	                     (setf res (make-hash-table-from-lr1-list res))))
   561	                 (unless (item-dot-right-p item)
   562	                   (let ((dot-symbol (item-dot-symbol item)))
   563	                     (dolist (production (grammar-productions grammar))
   564	                       (when (eq (production-symbol production) dot-symbol)
   565	                         (dolist (terminal
   566	                                   (sequence-first-terminals
   567	                                    (append (item-dot-right item 1)
   568	                                            (list (item-lookahead item)))
   569	                                    grammar))
   570	                           (add (make-lr1-item production 0 terminal))))))))))
   571	      (mapc #'add items)
   572	      res)))
   573	
   574	;;; Goto transitions
   575	
   576	(defstruct (goto
   577	             (:constructor make-goto (symbol target)))
   578	  (symbol nil :type symbol)
   579	  (target (required-argument) :type kernel))
   580	
   581	(declaim (inline goto-equal-p find-goto))
   582	
   583	(defun goto-equal-p (g1 g2)
   584	  (declare (type goto g1 g2))
   585	  (and (eq (goto-symbol g1) (goto-symbol g2))
   586	       ;; kernels are interned -- see make-kernel.
   587	       (eq (goto-target g1) (goto-target g2))))
   588	
   589	(defun find-goto (kernel symbol)
   590	  (declare (type kernel kernel) (symbol symbol))
   591	  (find symbol (kernel-gotos kernel) :key #'goto-symbol))
   592	
   593	(defun compute-goto (kernel symbol grammar)
   594	  "Compute the kernel of goto(KERNEL, SYMBOL)"
   595	  (declare (type kernel kernel) (symbol symbol) (type grammar grammar))
   596	  (let ((result '()))
   597	    (dolist (item (kernel-items kernel))
   598	      (when (not (item-dot-right-p item))
   599	        (let ((c (item-dot-symbol item)))
   600	          (when (eq c symbol)
   601	            (pushnew (item-shift item) result :test #'item-equal-p))
   602	          (dolist (production (grammar-productions grammar))
   603	            (when (and (not (null (production-derives production)))
   604	                       (eq symbol (car (production-derives production)))
   605	                       (member (production-symbol production)
   606	                               (derives-first c grammar)))
   607	              (pushnew (make-item production 1) result
   608	                       :test #'item-equal-p))))))
   609	    result))
   610	
   611	(defun compute-kernels (grammar)
   612	  "Compute the set collections of LR(0) items for GRAMMAR."
   613	  (declare (type grammar grammar))
   614	  (let ((p0 (car (grammar-productions grammar))))
   615	    (assert (= 1 (length (production-derives p0))))
   616	    (let ((kernels '()))
   617	      (declare (optimize (speed 3) (space 0)))
   618	      (labels
   619	          ((add-goto (kernel symbol)
   620	             (let* ((new-kernel*
   621	                     (compute-goto kernel symbol grammar))
   622	                    (new-kernel
   623	                     (and new-kernel*
   624	                          (make-kernel new-kernel* kernels)))
   625	                    (new-goto (and new-kernel
   626	                                   (make-goto symbol new-kernel))))
   627	               (when new-kernel
   628	                 (unless (memq new-kernel kernels)
   629	                   (add-kernel new-kernel))
   630	                 (unless (member new-goto (kernel-gotos kernel)
   631	                                 :test #'goto-equal-p)
   632	                   (push new-goto (kernel-gotos kernel))))))
   633	           (add-kernel (kernel)
   634	             (push kernel kernels)
   635	             (dolist (item (kernel-items kernel))
   636	               (unless (item-dot-right-p item)
   637	                 (add-goto kernel (item-dot-symbol item))))
   638	             (dolist (production (grammar-productions grammar))
   639	               (unless (null (production-derives production))
   640	                 (add-goto kernel (car (production-derives production)))))))
   641	        (add-kernel (make-kernel (list (make-item p0 0))))
   642	        (nreverse kernels)))))
   643	
   644	;;; Lookaheads
   645	
   646	(defun compute-lookaheads (kernel grammar &optional propagate-only)
   647	  "Compute the LR(1) lookaheads for all items in KERNEL.
   648	If PROPAGATE-ONLY is true, ignore spontaneous generation."
   649	  (declare (type kernel kernel) (type grammar grammar))
   650	  (let ((res '()))
   651	    (declare (optimize (speed 3) (space 0)))
   652	    (declare (list res))
   653	    (dolist (i (kernel-items kernel))
   654	      (let ((j (items-closure
   655	                (list (make-lr1-item (item-production i) (item-position i)
   656	                                     'propagate))
   657	                grammar)))
   658	        (do-lr1-collection (item j)
   659	          (unless (or (and propagate-only
   660	                           (not (eq 'propagate (item-lookahead item))))
   661	                      (item-dot-right-p item))
   662	            (push (cons i (lr1-item-shift item)) res)))))
   663	    res))
   664	
   665	(defun compute-all-lookaheads (kernels grammar)
   666	  "Compute the LR(1) lookaheads for all the collections in KERNELS."
   667	  (declare (list kernels) (type grammar grammar))
   668	  (setf (item-lookaheads (kernel-item (car kernels))) (list 'yacc-eof-symbol))
   669	  (let ((previously-changed kernels) (changed '())
   670	        (propagate-only nil))
   671	    (declare (optimize (speed 3) (space 0)))
   672	    (loop
   673	     (dolist (kernel kernels)
   674	       (when (memq kernel previously-changed)
   675	         (let ((lookaheads (compute-lookaheads kernel grammar propagate-only)))
   676	           (declare (list lookaheads))
   677	           (dolist (goto (kernel-gotos kernel))
   678	             (declare (type goto goto))
   679	             (let ((target (goto-target goto)) (new nil))
   680	               (flet ((new-lookahead (item lookahead)
   681	                        (declare (type lr1-item item) (symbol lookahead))
   682	                        (let ((i (find item (kernel-items target)
   683	                                       :test #'item-equal-p)))
   684	                          (when i
   685	                            (unless (memq lookahead (item-lookaheads i))
   686	                              (push lookahead (item-lookaheads i))
   687	                              (setq new t))))))
   688	                 (dolist (e lookaheads)
   689	                   (let ((i (car e)) (ni (cdr e)))
   690	                     (declare (type lr0-item i) (type lr1-item ni))
   691	                     (cond
   692	                       ((eq 'propagate (item-lookahead ni))
   693	                        ;; propagate
   694	                        (let ((item (find i (kernel-items kernel)
   695	                                          :test #'item-equal-p)))
   696	                          (when item
   697	                            (dolist (s (item-lookaheads item))
   698	                              (new-lookahead ni s)))))
   699	                       (t
   700	                        ;; spontaneous generation
   701	                        (new-lookahead ni (item-lookahead ni)))))))
   702	               (when new
   703	                 (pushnew target changed)))))))
   704	     (unless changed (return))
   705	     (psetq previously-changed changed changed '()
   706	            propagate-only t)))
   707	  kernels)
   708	
   709	(defun print-states (kernels lookaheads &optional (stream *standard-output*))
   710	  (declare (list kernels))
   711	  (let ((stream (etypecase stream
   712	             ((member nil) *standard-output*)
   713	             ((member t) *terminal-io*)
   714	             (stream stream))))
   715	    (declare (stream stream) #+CMU (optimize ext:inhibit-warnings))
   716	    (pprint-logical-block (stream kernels)
   717	      (loop
   718	       (pprint-exit-if-list-exhausted)
   719	       (let ((k (pprint-pop)))
   720	         (format stream "~S: " (kernel-id k))
   721	         (pprint-logical-block (stream (kernel-items k))
   722	           (loop
   723	            (pprint-exit-if-list-exhausted)
   724	            (let* ((item (pprint-pop)))
   725	              (if lookaheads
   726	                  (format stream "~S ~_~S~:@_" item (item-lookaheads item))
   727	                  (format stream "~S~:@_" item)))))
   728	         (format stream "~_"))))))
   729	
   730	;;; Parser generation
   731	
   732	(defun number-kernels (kernels)
   733	  "Set a unique ID for all kernels in KERNELS."
   734	  (declare (list kernels))
   735	  (let ((id 0))
   736	    (dolist (k kernels)
   737	      (setf (kernel-id k) id)
   738	      (incf id))))
   739	
   740	(defun print-goto-graph (kernels &optional (stream *standard-output*))
   741	  "Print the goto graph defined by KERNELS."
   742	  (declare (list kernels))
   743	  (let ((stream (etypecase stream
   744	             ((member nil) *standard-output*)
   745	             ((member t) *terminal-io*)
   746	             (stream stream))))
   747	    (declare (stream stream) #+CMU (optimize ext:inhibit-warnings))
   748	    (pprint-logical-block (stream kernels)
   749	      (loop
   750	       (pprint-exit-if-list-exhausted)
   751	       (let ((k (pprint-pop)))
   752	         (format stream "~S: " (kernel-id k))
   753	         (pprint-logical-block (stream (kernel-gotos k))
   754	           (loop
   755	            (pprint-exit-if-list-exhausted)
   756	            (let ((g (pprint-pop)))
   757	              (format stream "~S -> ~S ~@:_"
   758	                      (goto-symbol g) (kernel-id (goto-target g))))))
   759	         (format stream "~@:_"))))))
   760	
   761	(defstruct (action (:constructor nil)
   762	                   (:print-function print-action))
   763	  )
   764	
   765	(defstruct (accept-action (:include action))
   766	  )
   767	
   768	(defstruct (reduce-action (:include action)
   769	                          (:constructor make-reduce-action
   770	                                        (symbol length
   771	                                         &key action action-form)))
   772	  (symbol (required-argument) :type symbol)
   773	  (length (required-argument) :type index)
   774	  (action #'list :type function)
   775	  (action-form nil))
   776	
   777	(defstruct (shift-action (:include action)
   778	                         (:constructor
   779	                          make-shift-action (state)))
   780	  (state (required-argument) :type index))
   781	
   782	(defun action-equal-p (a1 a2)
   783	  (declare (type (or null action) a1 a2))
   784	  (or (eq a1 a2)
   785	      (and
   786	       (eq (type-of a1) (type-of a2))
   787	       (typecase a1
   788	         (reduce-action
   789	          (and (eq (reduce-action-symbol a1) (reduce-action-symbol a2))
   790	               (= (reduce-action-length a1) (reduce-action-length a2))
   791	               (eq (reduce-action-action a1) (reduce-action-action a2))))
   792	         (shift-action
   793	          (= (shift-action-state a1) (shift-action-state a2)))
   794	         (t t)))))
   795	
   796	(defun print-action (a s d)
   797	  (declare (type action a) (stream s) (ignore d))
   798	  (print-unreadable-object (a s :type t)
   799	    (typecase a
   800	      (reduce-action
   801	       (format s "~S (~D)" (reduce-action-symbol a) (reduce-action-length a)))
   802	      (shift-action
   803	       (format s "~D" (shift-action-state a))))))
   804	
   805	(define-condition yacc-compile-warning (warning)
   806	  ())
   807	
   808	(define-condition conflict-warning (yacc-compile-warning simple-warning)
   809	  ((kind :initarg :kind :reader conflict-warning-kind)
   810	   (state :initarg :state :reader conflict-warning-state)
   811	   (terminal :initarg :terminal :reader conflict-warning-terminal))
   812	  (:report (lambda (w stream)
   813	             (format stream "~A conflict on terminal ~S in state ~A, ~_~?"
   814	                     (case (conflict-warning-kind w)
   815	                       (:shift-reduce "Shift/Reduce")
   816	                       (:reduce-reduce "Reduce/Reduce")
   817	                       (t (conflict-warning-kind w)))
   818	                     (conflict-warning-terminal w)
   819	                     (conflict-warning-state w)
   820	                     (simple-condition-format-control w)
   821	                     (simple-condition-format-arguments w)))))
   822	
   823	(define-condition conflict-summary-warning (yacc-compile-warning)
   824	  ((shift-reduce :initarg :shift-reduce
   825	                 :reader conflict-summary-warning-shift-reduce)
   826	   (reduce-reduce :initarg :reduce-reduce
   827	                  :reader conflict-summary-warning-reduce-reduce))
   828	  (:report (lambda (w stream)
   829	             (format stream "~D Shift/Reduce, ~D Reduce/Reduce conflicts"
   830	                     (conflict-summary-warning-shift-reduce w)
   831	                     (conflict-summary-warning-reduce-reduce w)))))
   832	
   833	(defstruct (parser (:constructor %make-parser (states goto action)))
   834	  (states (required-argument) :type index)
   835	  (goto (required-argument) :type simple-vector)
   836	  (action (required-argument) :type simple-vector))
   837	
   838	(defun find-precedence (op precedence)
   839	  "Return the tail of PRECEDENCE starting with the element containing OP.
   840	PRECEDENCE is a list of elements of the form (KEYWORD . (op...))."
   841	  (declare (symbol op))
   842	  (cond
   843	    ((null precedence) '())
   844	    ((member op (cdar precedence)) precedence)
   845	    (t (find-precedence op (cdr precedence)))))
   846	
   847	(defun find-single-terminal (s grammar)
   848	  "Return the only terminal in S, or NIL if none or multiple."
   849	  (declare (list s) (type grammar grammar))
   850	  (cond
   851	    ((null s) nil)
   852	    ((terminal-p (car s) grammar)
   853	     (and (not (member-if #'(lambda (s) (terminal-p s grammar)) (cdr s)))
   854	          (car s)))
   855	    (t (find-single-terminal (cdr s) grammar))))
   856	
   857	(defun handle-conflict (a1 a2 grammar action-productions id s
   858	                        &optional muffle-conflicts)
   859	  "Decide what to do with a conflict between A1 and A2 in state ID on symbol S.
   860	Returns three actions: the chosen action, the number of new sr and rr."
   861	  (declare (type action a1 a2) (type grammar grammar)
   862	           (type index id) (symbol s))
   863	  (when (action-equal-p a1 a2)
   864	    (return-from handle-conflict (values a1 0 0)))
   865	  (when (and (shift-action-p a2) (reduce-action-p a1))
   866	    (psetq a1 a2 a2 a1))
   867	  (let ((p1 (cdr (assoc a1 action-productions)))
   868	        (p2 (cdr (assoc a2 action-productions))))
   869	    ;; operator precedence and associativity
   870	    (when (and (shift-action-p a1) (reduce-action-p a2))
   871	      (let* ((op1 (find-single-terminal (production-derives p1) grammar))
   872	             (op2 (find-single-terminal (production-derives p2) grammar))
   873	             (op1-tail (find-precedence op1 (grammar-precedence grammar)))
   874	             (op2-tail (find-precedence op2 (grammar-precedence grammar))))
   875	        (when (and (eq s op1) op1-tail op2-tail)
   876	          (cond
   877	            ((eq op1-tail op2-tail)
   878	             (return-from handle-conflict
   879	               (ecase (caar op1-tail)
   880	                 ((:left) (values a2 0 0))
   881	                 ((:right) (values a1 0 0))
   882	                 ((:nonassoc) (values nil 0 0)))))
   883	            (t
   884	             (return-from handle-conflict
   885	               (if (tailp op2-tail (cdr op1-tail))
   886	                   (values a1 0 0)
   887	                   (values a2 0 0))))))))
   888	    ;; default: prefer shift or first production
   889	    (unless muffle-conflicts
   890	      (warn (make-condition
   891	             'conflict-warning
   892	             :kind (typecase a1
   893	                     (shift-action :shift-reduce)
   894	                     (t :reduce-reduce))
   895	             :state id :terminal s
   896	             :format-control "~S and ~S~@[ ~_~A~]~@[ ~_~A~]"
   897	             :format-arguments (list a1 a2 p1 p2))))
   898	    (typecase a1
   899	      (shift-action (values a1 1 0))
   900	      (t (values a1 0 1)))))
   901	
   902	(defun compute-parsing-tables (kernels grammar
   903	                               &key muffle-conflicts)
   904	  "Compute the parsing tables for grammar GRAMMAR and transitions KERNELS.
   905	PRECEDENCE is as in FIND-PRECEDENCE.  MUFFLE-WARNINGS is one of NIL, T, :SOME
   906	or a list of the form (sr rr)."
   907	  (declare (list kernels) (type grammar grammar))
   908	  (let ((numkernels (length kernels)))
   909	    (let ((goto (make-array numkernels :initial-element '()))
   910	          (action (make-array numkernels :initial-element '()))
   911	          (sr-conflicts 0) (rr-conflicts 0)
   912	          (epsilon-productions (grammar-epsilon-productions grammar))
   913	          (action-productions '()))
   914	      (declare (fixnum sr-conflicts rr-conflicts))
   915	      (flet ((set-action (k symbols a production)
   916	               (push (cons a production) action-productions)
   917	               (let ((id (kernel-id k)))
   918	                 (dolist (s symbols)
   919	                   (declare (symbol s))
   920	                   (let ((s-a (assoc s (aref action id))))
   921	                     (cond
   922	                       ((cdr s-a)
   923	                        (multiple-value-bind (new-action s-r r-r)
   924	                            (handle-conflict
   925	                             (cdr s-a) a grammar action-productions
   926	                             id s muffle-conflicts)
   927	                          (setf (cdr s-a) new-action)
   928	                          (incf sr-conflicts s-r) (incf rr-conflicts r-r)))
   929	                       (s-a
   930	                        (setf (cdr s-a) a))
   931	                       (t (push (cons s a) (aref action id))))))))
   932	             (set-goto (k symbols target)
   933	               (let ((i (kernel-id k)) (j (kernel-id target)))
   934	                 (dolist (s symbols)
   935	                   (declare (symbol s))
   936	                   (let ((e (assoc s (aref goto i))))
   937	                     (when e
   938	                       (assert (eq j (cdr e)))
   939	                       (return-from set-goto)))
   940	                   (push (cons s j) (aref goto i))))))
   941	        (do* ((ks kernels (cdr ks)) (k (car ks) (car ks)))
   942	             ((null ks))
   943	          (dolist (item (kernel-items k))
   944	            (cond
   945	              ((item-dot-right-p item)
   946	               ;; non-epsilon reduction
   947	               (let ((la (item-lookaheads item)))
   948	                 (cond
   949	                   ((and (eq 's-prime (item-symbol item))
   950	                         (= 1 (item-position item)))
   951	                    (when (member 'yacc-eof-symbol la)
   952	                      (set-action k (list 'yacc-eof-symbol)
   953	                                  (make-accept-action)
   954	                                  (item-production item))))
   955	                   (t
   956	                    (set-action k la
   957	                                (make-reduce-action
   958	                                 (item-symbol item)
   959	                                 (length (item-derives item))
   960	                                 :action (item-action item)
   961	                                 :action-form (item-action-form item))
   962	                                (item-production item))))))
   963	              (t
   964	               (let ((c (item-dot-symbol item)))
   965	                 ;; shift
   966	                 (let ((a (derives-first-terminal c grammar)))
   967	                   (dolist (s a)
   968	                     (let ((g (find-goto k s)))
   969	                       (when g
   970	                         (set-action k (list s)
   971	                                     (make-shift-action
   972	                                      (kernel-id (goto-target g)))
   973	                                     (item-production item))))))
   974	                 ;; epsilon reduction
   975	                 (dolist (a-epsilon epsilon-productions)
   976	                   (let ((a (production-symbol a-epsilon)))
   977	                     (when (member a (derives-first c grammar))
   978	                       (let* ((first-eta
   979	                               (relative-first c a grammar))
   980	                              (first-eta-delta
   981	                               (combine-first first-eta
   982	                                              (item-dot-right item 1) grammar))
   983	                              (first-eta-delta-b
   984	                               (if (member 'epsilon first-eta-delta)
   985	                                   (union (remove 'epsilon first-eta-delta)
   986	                                          (item-lookaheads item))
   987	                                   first-eta-delta)))
   988	                         (set-action
   989	                          k first-eta-delta-b
   990	                          (make-reduce-action
   991	                           a 0
   992	                           :action (production-action a-epsilon)
   993	                           :action-form (production-action-form a-epsilon))
   994	                          a-epsilon)
   995	                         ))))
   996	                 ))))
   997	          (dolist (g (kernel-gotos k))
   998	            (when (not (terminal-p (goto-symbol g) grammar))
   999	              (set-goto k (list (goto-symbol g)) (goto-target g))))))
  1000	      (when (null muffle-conflicts) (setq muffle-conflicts '(0 0)))
  1001	      (unless (or (eq t muffle-conflicts)
  1002	                  (and (consp muffle-conflicts)
  1003	                       (= (car muffle-conflicts) sr-conflicts)
  1004	                       (= (cadr muffle-conflicts) rr-conflicts)))
  1005	        (warn (make-condition 'conflict-summary-warning
  1006	                              :shift-reduce sr-conflicts
  1007	                              :reduce-reduce rr-conflicts)))
  1008	      (%make-parser numkernels goto action))))
  1009	
  1010	(defun make-parser (grammar
  1011	                    &key (discard-memos t) (muffle-conflicts nil)
  1012	                    (print-derives-epsilon nil) (print-first-terminals nil)
  1013	                    (print-states nil)
  1014	                    (print-goto-graph nil) (print-lookaheads nil))
  1015	  "Returns a parser for the given grammar.
  1016	If MUFFLE-CONFLICTS is NIL, then a warning will be signaled for all conflicts.
  1017	If it is T, then no warnings will be signaled.  If it is a list of the form
  1018	(SR SS), then a warning will be signaled unless there are exactly SR
  1019	shift-reduce conflicts and SS shift-shift conflicts."
  1020	  (declare (type grammar grammar))
  1021	  (let ((kernels (compute-kernels grammar)))
  1022	    (compute-all-lookaheads kernels grammar)
  1023	    (number-kernels kernels)
  1024	    (when print-derives-epsilon (print-derives-epsilon grammar))
  1025	    (when print-first-terminals (print-first-terminals grammar))
  1026	    (when print-goto-graph (print-goto-graph kernels))
  1027	    (when (or print-states print-lookaheads)
  1028	      (print-states kernels print-lookaheads))
  1029	    (prog1
  1030	        (compute-parsing-tables kernels grammar
  1031	                                :muffle-conflicts muffle-conflicts)
  1032	      (when discard-memos (grammar-discard-memos grammar)))))
  1033	
  1034	(define-condition yacc-runtime-error (error)
  1035	  ()
  1036	)
  1037	
  1038	(define-condition yacc-parse-error (yacc-runtime-error)
  1039	  ((terminal :initarg :terminal :reader yacc-parse-error-terminal)
  1040	   (value :initarg :value :reader yacc-parse-error-value)
  1041	   (expected-terminals :initarg :expected-terminals
  1042	                       :reader yacc-parse-error-expected-terminals))
  1043	  (:report (lambda (e stream)
  1044	             (format stream "Unexpected terminal ~S (value ~S). ~@:_~
  1045	                             Expected one of: ~S"
  1046	                     (yacc-parse-error-terminal e)
  1047	                     (yacc-parse-error-value e)
  1048	                     (yacc-parse-error-expected-terminals e)))))
  1049	
  1050	(defun parse-with-lexer (lexer parser)
  1051	"Parse the stream of symbols provided by LEXER using PARSER.
  1052	LEXER is a function of no arguments returning a symbol and a semantic value,
  1053	and should return (VALUES NIL NIL) when the end of input is reached.
  1054	Handle YACC-PARSE-ERROR to provide custom error reporting."
  1055	  (declare (type (function () (values symbol t)) lexer))
  1056	  (declare (type parser parser))
  1057	  (let ((action-array (parser-action parser))
  1058	        (goto-array (parser-goto parser)))
  1059	    (flet ((action (i a)
  1060	             (declare (type index i) (symbol a))
  1061	             (cdr (assoc a (aref action-array i))))
  1062	           (goto (i a)
  1063	             (declare (type index i) (symbol a))
  1064	             (or (cdr (assoc a (aref goto-array i)))
  1065	                 (error "This cannot happen."))))
  1066	      (let ((stack (list 0)) symbol value)
  1067	        (flet ((next-symbol ()
  1068	                 (multiple-value-bind (s v) (funcall lexer)
  1069	                   (setq symbol (or s 'yacc-eof-symbol) value v))))
  1070	          (next-symbol)
  1071	          (loop
  1072	           (let* ((state (car stack))
  1073	                  (action (action state symbol)))
  1074	             (etypecase action
  1075	               (shift-action
  1076	                (push value stack)
  1077	                (push (shift-action-state action) stack)
  1078	                (next-symbol))
  1079	               (reduce-action
  1080	                (let ((vals '()))
  1081	                  (dotimes (n (reduce-action-length action))
  1082	                    (pop stack)
  1083	                    (push (pop stack) vals))
  1084	                  (let ((s* (car stack)))
  1085	                    (push (apply (reduce-action-action action) vals) stack)
  1086	                    (push (goto s* (reduce-action-symbol action)) stack))))
  1087	               (accept-action
  1088	                (pop stack)
  1089	                (return (pop stack)))
  1090	               (null
  1091	                (error (make-condition
  1092	                        'yacc-parse-error
  1093	                        :terminal (if (eq symbol 'yacc-eof-symbol) nil symbol)
  1094	                        :value value
  1095	                        :expected-terminals
  1096	                        (mapcan
  1097	                         #'(lambda (e)
  1098	                             (and (cdr e)
  1099	                                  (list
  1100	                                   (if (eq (car e) 'yacc-eof-symbol)
  1101	                                       nil
  1102	                                       (car e)))))
  1103	                         (aref action-array state)))))
  1104	               ))))))))
  1105	
  1106	;;; User interface
  1107	
  1108	(defun parse-production (form)
  1109	  (let ((symbol (car form))
  1110	        (productions '()))
  1111	    (dolist (stuff (cdr form))
  1112	      (cond
  1113	        ((and (symbolp stuff) (not (null stuff)))
  1114	         (push (make-production symbol (list stuff)
  1115	                                :action #'identity :action-form '#'identity)
  1116	               productions))
  1117	        ((listp stuff)
  1118	         (let ((l (car (last stuff))))
  1119	           (let ((rhs (if (symbolp l) stuff (butlast stuff)))
  1120	                 (action (if (symbolp l) '#'list l)))
  1121	             (push (make-production symbol rhs
  1122	                     :action (eval action)
  1123	                     :action-form action)
  1124	                   productions))))
  1125	        (t (error "Unexpected production ~S" stuff))))
  1126	    productions))
  1127	
  1128	(defun parse-grammar (forms)
  1129	  (let ((options '()) (make-options '()) (productions '()))
  1130	    (dolist (form forms)
  1131	      (cond
  1132	        ((member (car form)
  1133	                 '(:muffle-conflicts
  1134	                   :print-derives-epsilon :print-first-terminals
  1135	                   :print-states :print-goto-graph :print-lookaheads))
  1136	         (unless (null (cddr form))
  1137	           (error "Malformed option ~S" form))
  1138	         (push (car form) make-options)
  1139	         (push (cadr form) make-options))
  1140	        ((keywordp (car form))
  1141	         (unless (null (cddr form))
  1142	           (error "Malformed option ~S" form))
  1143	         (push (car form) options)
  1144	         (push (cadr form) options))
  1145	        ((symbolp (car form))
  1146	         (setq productions (nconc (parse-production form) productions)))
  1147	        (t
  1148	         (error "Unexpected grammar production ~S" form))))
  1149	    (values (nreverse options) (nreverse make-options)
  1150	            (nreverse productions))))
  1151	
  1152	(defmacro define-grammar (name &body body)
  1153	  "DEFINE-GRAMMAR NAME OPTION... PRODUCTION...
  1154	PRODUCTION ::= (SYMBOL RHS...)
  1155	RHS ::= SYMBOL | (SYMBOL... [ACTION])
  1156	Defines the special variable NAME to be a grammar.  Options are as in
  1157	MAKE-GRAMMAR."
  1158	  (multiple-value-bind (options make-options productions) (parse-grammar body)
  1159	    (unless (null make-options)
  1160	      (warn "DEFINE-GRAMMAR ignores options ~S" make-options))
  1161	    `(defparameter ,name
  1162	      ',(apply #'make-grammar
  1163	               :name name
  1164	               :productions productions
  1165	               options))))
  1166	
  1167	(defmacro define-parser (name &body body)
  1168	  "DEFINE-GRAMMAR NAME OPTION... PRODUCTION...
  1169	PRODUCTION ::= (SYMBOL RHS...)
  1170	RHS ::= SYMBOL | (SYMBOL... [ACTION])
  1171	Defines the special variable NAME to be a parser.  Options are as in
  1172	MAKE-GRAMMAR and MAKE-PARSER."
  1173	  (multiple-value-bind (options make-options productions) (parse-grammar body)
  1174	    `(defparameter ,name
  1175	      ',(apply #'make-parser
  1176	               (apply #'make-grammar
  1177	                      :name name
  1178	                      :productions productions
  1179	                      options)
  1180	               make-options))))
  1181	
  1182	;;; Support for fasdumping grammars and parsers.
  1183	
  1184	(defmethod make-load-form ((p production) &optional env)
  1185	  (declare (ignore env))
  1186	  (when (null (production-action-form p))
  1187	    (error "Production ~S cannot be dumped (it has no action form)" p))
  1188	  (values
  1189	   `(make-production ',(production-symbol p) ',(production-derives p))
  1190	   `(setf (production-action-form ,p) ',(production-action-form p)
  1191	          (production-action ,p) (eval ',(production-action-form p)))))
  1192	
  1193	(defmethod make-load-form ((g grammar) &optional env)
  1194	  (make-load-form-saving-slots g :environment env))
  1195	
  1196	(defmethod make-load-form ((p parser) &optional env)
  1197	  (make-load-form-saving-slots p :environment env))
  1198	
  1199	(defmethod make-load-form ((a accept-action) &optional env)
  1200	  (declare (ignore env))
  1201	  `(make-accept-action))
  1202	
  1203	(defmethod make-load-form ((a reduce-action) &optional env)
  1204	  (declare (ignore env))
  1205	  (when (null (reduce-action-action-form a))
  1206	    (error "Action ~S cannot be dumped (it has no action form)" a))
  1207	  (values
  1208	   `(make-reduce-action ',(reduce-action-symbol a) ',(reduce-action-length a))
  1209	   `(setf (reduce-action-action-form ,a) ',(reduce-action-action-form a)
  1210	          (reduce-action-action ,a) (eval ',(reduce-action-action-form a)))))
  1211	
  1212	(defmethod make-load-form ((a shift-action) &optional env)
  1213	  (declare (ignore env))
  1214	  `(make-shift-action ',(shift-action-state a)))
